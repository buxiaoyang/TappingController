C51 COMPILER V7.50   UART                                                                  08/09/2014 19:19:49 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\output\uart.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE source\uart.c LARGE BROWSE INCDIR(.\include\) DEBUG OBJECTEXTEND PRINT(.\li
                    -sting\uart.lst) OBJECT(.\output\uart.obj)

line level    source

   1          #include <uart.h>
   2          #include <reg52.h>
   3          #include <intrins.h>
   4          #include <parameter.h>
   5          #include <dispatch.h>
   6          
   7          #define FOSC 11059200L      //System frequency
   8          #define BAUD 115200         //UART baudrate
   9          
  10          /*Define UART parity mode*/
  11          #define NONE_PARITY     0   //None parity
  12          #define ODD_PARITY      1   //Odd parity
  13          #define EVEN_PARITY     2   //Even parity
  14          #define MARK_PARITY     3   //Mark parity
  15          #define SPACE_PARITY    4   //Space parity
  16          
  17          #define PARITYBIT NONE_PARITY   //Testing even parity
  18          
  19          /*Declare SFR associated with the UART2 */
  20          sfr AUXR  = 0x8e;           //Auxiliary register
  21          sfr S2CON = 0x9a;           //UART2 control register
  22          sfr S2BUF = 0x9b;           //UART2 data buffer
  23          sfr BRT   = 0x9c;           //Baudrate generator
  24          sfr IE2   = 0xaf;           //Interrupt control 2
  25          
  26          #define S2RI  0x01          //S2CON.0
  27          #define S2TI  0x02          //S2CON.1
  28          #define S2RB8 0x04          //S2CON.2
  29          #define S2TB8 0x08          //S2CON.3
  30          
  31          bit busy;
  32          bit uartReceiveOK = 0;
  33          
  34          BYTE uartBuffer[15] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
  35          
  36          BYTE receiveSteps = 0;  // 0: 没有数据接收
  37                                                          // 1: 接收到5A
  38                                                          // 2：接收到A5
  39                                                          // 3：接收到数据长度
  40                                                          // 4: 接收数据
  41                                                          // 5：确定指令动作
  42          BYTE dataIndex = 0;
  43          BYTE dataLength = 0;
  44            
  45          void SendData(BYTE dat);
  46          void SendString(char *s);
  47          void ReceiveData(BYTE dat);
  48          void anyData();
  49          
  50          void uart_init()
  51          {
  52   1      #if (PARITYBIT == NONE_PARITY)
  53   1          S2CON = 0x50;           //8-bit variable UART
  54   1      #elif (PARITYBIT == ODD_PARITY) || (PARITYBIT == EVEN_PARITY) || (PARITYBIT == MARK_PARITY)
C51 COMPILER V7.50   UART                                                                  08/09/2014 19:19:49 PAGE 2   

                  S2CON = 0xda;           //9-bit variable UART, parity bit initial to 1
              #elif (PARITYBIT == SPACE_PARITY)
                  S2CON = 0xd2;           //9-bit variable UART, parity bit initial to 0
              #endif
  59   1      
  60   1          BRT = -(FOSC/32/BAUD);  //Set auto-reload vaule of baudrate generator
  61   1          AUXR = 0x14;            //Baudrate generator work in 1T mode
  62   1          IE2 = 0x01;             //Enable UART2 interrupt
  63   1          EA = 1;                 //Open master interrupt switch
  64   1      
  65   1          //SendString("STC12C5A60S2\r\nUart2 Test !\r\n");
  66   1          //while(1);
  67   1      }
  68          
  69          /*----------------------------
  70          UART2 interrupt service routine
  71          ----------------------------*/
  72          void Uart2() interrupt 8 using 1
  73          {
  74   1          if (S2CON & S2RI)
  75   1          {
  76   2              S2CON &= ~S2RI;     //Clear receive interrupt flag
  77   2              ReceiveData(S2BUF);
  78   2                      //P2 = S2BUF;         //P0 show UART data
  79   2              //P2 = (S2CON & S2RB8);//P2.2 show parity bit
  80   2          }
  81   1          if (S2CON & S2TI)
  82   1          {
  83   2              S2CON &= ~S2TI;     //Clear transmit interrupt flag
  84   2              busy = 0;           //Clear transmit busy flag
  85   2          }
  86   1      }
  87          
  88          /*----------------------------
  89          Send a byte data to UART
  90          Input: dat (data to be sent)
  91          Output:None
  92          ----------------------------*/
  93          void SendData(BYTE dat)
  94          {
  95   1          while (busy);           //Wait for the completion of the previous data is sent
  96   1          ACC = dat;              //Calculate the even parity bit P (PSW.0)
  97   1          if (P)                  //Set the parity bit according to P
  98   1          {
  99   2      #if (PARITYBIT == ODD_PARITY)
                      S2CON &= ~S2TB8;    //Set parity bit to 0
              #elif (PARITYBIT == EVEN_PARITY)
                      S2CON |= S2TB8;     //Set parity bit to 1
              #endif
 104   2          }
 105   1          else
 106   1          {
 107   2      #if (PARITYBIT == ODD_PARITY)
                      S2CON |= S2TB8;     //Set parity bit to 1
              #elif (PARITYBIT == EVEN_PARITY)
                      S2CON &= ~S2TB8;    //Set parity bit to 0
              #endif
 112   2          }
 113   1          busy = 1;
 114   1          S2BUF = ACC;            //Send data to UART2 buffer
 115   1      }
 116          
C51 COMPILER V7.50   UART                                                                  08/09/2014 19:19:49 PAGE 3   

 117          /*----------------------------
 118          Send a string to UART
 119          Input: s (address of string)
 120          Output:None
 121          ----------------------------*/
 122          void SendString(char *s)
 123          {
 124   1          while (*s)              //Check the end of the string
 125   1          {
 126   2              SendData(*s++);     //Send current char and increment string ptr
 127   2          }
 128   1      }
 129          
 130          void SendDataToScreen(WORD address, WORD dat)
 131          {
 132   1              SendData(0x5A);
 133   1              SendData(0xA5);
 134   1              SendData(0x05);
 135   1              SendData(0x82);
 136   1              SendData(address>>8);
 137   1              SendData(address);
 138   1              SendData(dat>>8);
 139   1              SendData(dat);
 140   1      }
 141          
 142          void ChangeScreenPage(WORD page)
 143          {
 144   1              SendData(0x5A);
 145   1              SendData(0xA5);
 146   1              SendData(0x04);
 147   1              SendData(0x80);
 148   1              SendData(0x03);
 149   1              SendData(page>>8);
 150   1              SendData(page);
 151   1      }
 152          
 153          void ReceiveData(BYTE dat)
 154          {
 155   1              // 0: 接收到5A
 156   1              // 1：接收到A5
 157   1              // 2：接收到数据长度
 158   1              // 3: 接收数据
 159   1              // 4：确定指令动作
 160   1              switch(receiveSteps)
 161   1              {
 162   2                      case 0:
 163   2                              if(dat == 0x5A)
 164   2                              {
 165   3                                      receiveSteps ++;
 166   3                              }
 167   2                      break;
 168   2                      case 1:
 169   2                              if(dat == 0xA5)
 170   2                              {
 171   3                                      receiveSteps ++;
 172   3                              }
 173   2                              else
 174   2                              {
 175   3                                      receiveSteps = 0;
 176   3                              }
 177   2                      break;
 178   2                      case 2:
C51 COMPILER V7.50   UART                                                                  08/09/2014 19:19:49 PAGE 4   

 179   2                              dataLength = dat;
 180   2                              dataIndex = 0;
 181   2                              receiveSteps ++;
 182   2                      break;
 183   2                      case 3:
 184   2                              uartBuffer[dataIndex] = dat;
 185   2                              dataIndex ++;
 186   2                              if(dataIndex >= dataLength)
 187   2                              {
 188   3                                      anyData();
 189   3                                      receiveSteps = 0;
 190   3                              }
 191   2                      break;
 192   2                      default:
 193   2                              _nop_();
 194   2                              receiveSteps = 0;
 195   2              }
 196   1      }
 197          
 198          void cancelcylinderAlarm()
 199          {
 200   1              if(cylinderOut1 == 0)
 201   1              {
 202   2                      cylinder1 = 1;
 203   2              }
 204   1              else
 205   1              {
 206   2                      cylinder1 = 0;
 207   2              }
 208   1      
 209   1              if(cylinderOut2 == 0)
 210   1              {
 211   2                      cylinder2 = 1;
 212   2              }
 213   1              else
 214   1              {
 215   2                      cylinder2 = 0;
 216   2              }
 217   1      
 218   1              if(cylinderOut3 == 0)
 219   1              {
 220   2                      cylinder3 = 1;
 221   2              }
 222   1              else
 223   1              {
 224   2                      cylinder3 = 0;
 225   2              }
 226   1      
 227   1              if(cylinderOut4 == 0)
 228   1              {
 229   2                      cylinder4 = 1;
 230   2              }
 231   1              else
 232   1              {
 233   2                      cylinder4 = 0;
 234   2              }
 235   1      
 236   1              if(cylinderOut5 == 0)
 237   1              {
 238   2                      cylinder5 = 1;
 239   2              }
 240   1              else
C51 COMPILER V7.50   UART                                                                  08/09/2014 19:19:49 PAGE 5   

 241   1              {
 242   2                      cylinder5 = 0;
 243   2              }
 244   1      }
 245          
 246          void anyData()
 247          {
 248   1              WORD dat = ((uartBuffer[4]<<8) | uartBuffer[5]);
 249   1              refreshDisplay = 1;
 250   1              if(uartBuffer[2] == 0x00)//运行模式     0：手动模式(停止)  1：自动模式(停止) 2：手动模式(启动) 3：自动模式(启
             -动)   返回数据0xEE
 251   1              {
 252   2                      if(runMode == 0 || runMode == 2)
 253   2                      {
 254   3                              runMode = 1;    
 255   3                      }
 256   2                      else
 257   2                      {
 258   3                              runMode = 0;
 259   3                      }
 260   2              }
 261   1              else if(uartBuffer[2] == 0x01)  //电机状态      0：电机停止   1：电机启动  返回数据0xEE
 262   1              {
 263   2                      if(montorMode == 0)
 264   2                      {
 265   3                              montorMode = 1;
 266   3                      }
 267   2                      else
 268   2                      {
 269   3                              montorMode = 0;
 270   3                      }
 271   2              }
 272   1              else if(uartBuffer[2] == 0x11)  //时间设置1     字(int) 最大9.9
 273   1              {
 274   2                      intervalTimer1 = dat;
 275   2                      parameter_save();
 276   2              }
 277   1              else if(uartBuffer[2] == 0x12)  //时间设置2     字(int)
 278   1              {
 279   2                      intervalTimer2 = dat;
 280   2                      parameter_save();
 281   2              }
 282   1              else if(uartBuffer[2] == 0x13)  //时间设置3     字(int)
 283   1              {
 284   2                      intervalTimer3 = dat;
 285   2                      parameter_save();
 286   2              }
 287   1              else if(uartBuffer[2] == 0x14)  //时间设置4     字(int)
 288   1              {
 289   2                      intervalTimer4 = dat;
 290   2                      parameter_save();
 291   2              }
 292   1              else if(uartBuffer[2] == 0x15)  //时间设置5     字(int)
 293   1              {
 294   2                      intervalTimer5 = dat;
 295   2                      parameter_save();
 296   2              }
 297   1              else if(uartBuffer[2] == 0x16)  //时间设置6     字(int)
 298   1              {
 299   2                      intervalTimer6 = dat;
 300   2                      parameter_save();
 301   2              }
C51 COMPILER V7.50   UART                                                                  08/09/2014 19:19:49 PAGE 6   

 302   1              else if(uartBuffer[2] == 0x17)  //时间设置7     字(int)
 303   1              {
 304   2                      intervalTimer7 = dat;
 305   2                      parameter_save();
 306   2              }
 307   1              else if(uartBuffer[2] == 0x18)  //报警设置 气缸1        字(int)
 308   1              {
 309   2                      cylinderAlarm1 = dat;
 310   2                      parameter_save();       
 311   2              }
 312   1              else if(uartBuffer[2] == 0x19)  //报警设置 气缸2        字(int)
 313   1              {
 314   2                      cylinderAlarm2 = dat;
 315   2                      parameter_save();
 316   2              }
 317   1              else if(uartBuffer[2] == 0x1A)  //报警设置 气缸3        字(int)
 318   1              {
 319   2                      cylinderAlarm3 = dat;
 320   2                      parameter_save();
 321   2              }
 322   1              else if(uartBuffer[2] == 0x1B)  //报警设置 气缸4        字(int)
 323   1              {
 324   2                      cylinderAlarm4 = dat;
 325   2                      parameter_save();
 326   2              }
 327   1              else if(uartBuffer[2] == 0x1C)  //报警设置 气缸5        字(int)
 328   1              {
 329   2                      cylinderAlarm5 = dat;
 330   2                      parameter_save();
 331   2              }
 332   1              else if(uartBuffer[2] == 0x1D)  //复位计数按钮  返回数据0xEE
 333   1              {
 334   2                      pieceCount = 0;
 335   2              }
 336   1              else if(uartBuffer[2] == 0x1E)  //手动模式 按钮 气缸1   0：关闭  1：开启
 337   1              {
 338   2                      if(cylinder1)
 339   2                      {
 340   3                              cylinder1 = 0;
 341   3                              cylinderOut1 = 1;
 342   3                      }
 343   2                      else
 344   2                      {
 345   3                              cylinder1 = 1;
 346   3                              cylinderOut1 = 0;       
 347   3                      }
 348   2              }
 349   1              else if(uartBuffer[2] == 0x1F)  //手动模式 按钮 气缸2   0：关闭  1：开启
 350   1              {
 351   2                      if(cylinder2)
 352   2                      {
 353   3                              cylinder2 = 0;
 354   3                              cylinderOut2 = 1;
 355   3                      }
 356   2                      else
 357   2                      {
 358   3                              cylinder2 = 1;
 359   3                              cylinderOut2 = 0;       
 360   3                      }
 361   2              }
 362   1              else if(uartBuffer[2] == 0x20)  //手动模式 按钮 气缸3   0：关闭  1：开启
 363   1              {
C51 COMPILER V7.50   UART                                                                  08/09/2014 19:19:49 PAGE 7   

 364   2                      if(cylinder3)
 365   2                      {
 366   3                              cylinder3 = 0;
 367   3                              cylinderOut3 = 1;
 368   3                      }
 369   2                      else
 370   2                      {
 371   3                              cylinder3 = 1;
 372   3                              cylinderOut3 = 0;       
 373   3                      }
 374   2              }
 375   1              else if(uartBuffer[2] == 0x21)  //手动模式 按钮 气缸4   0：关闭  1：开启
 376   1              {
 377   2                      if(cylinder4)
 378   2                      {
 379   3                              cylinder4 = 0;
 380   3                              cylinderOut4 = 1;
 381   3                      }
 382   2                      else
 383   2                      {
 384   3                              cylinder4 = 1;
 385   3                              cylinderOut4 = 0;       
 386   3                      }
 387   2              }
 388   1              else if(uartBuffer[2] == 0x22)  //手动模式 按钮 气缸5   0：关闭  1：开启
 389   1              {
 390   2                      if(cylinder5)
 391   2                      {
 392   3                              cylinder5 = 0;
 393   3                              cylinderOut5 = 1;
 394   3                      }
 395   2                      else
 396   2                      {
 397   3                              cylinder5 = 1;
 398   3                              cylinderOut5 = 0;       
 399   3                      }
 400   2              }
 401   1              else if(uartBuffer[2] == 0x24)  //解除警报按钮  返回数据0xEE
 402   1              {
 403   2                      alarmMode = 0;
 404   2                      cylinderAlarmCount = 0;
 405   2                      systemAlarmOut = 1;
 406   2                      cancelcylinderAlarm();
 407   2              }
 408   1              uartReceiveOK = 1;      
 409   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    878    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     18       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
